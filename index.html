<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esquivador Espacial</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(to bottom, #2c3e50, #4ca1af);
            margin: 0;
            font-family: Arial, sans-serif;
            color: white;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            border-radius: 15px;
            box-shadow: 0px 0px 30px rgba(0, 0, 0, 0.7);
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 28px;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            font-weight: bold;
        }
        #attribution {
            position: absolute;
            top: 3px;
            right: 29px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="700" height="450"></canvas>
        <div id="score">Puntos: 0</div>
        <div id="attribution">Jonathan Montoya</div>
    </div>
    <script>
        const sounds = {
            transform: new Audio('https://assets.mixkit.co/active_storage/sfx/2019/transformation.mp3'),
            powerup: new Audio('https://assets.mixkit.co/active_storage/sfx/2020/powerup.mp3'),
            thunder: new Audio('https://assets.mixkit.co/active_storage/sfx/2018/thunder.mp3')
        };

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");

        const auraLevels = [
            { score: 10, color: 'rgba(255, 215, 0, 0.3)', radius: 10, particles: 8, name: 'Ssj' },
            { score: 15, color: 'rgba(255, 215, 0, 0.4)', radius: 15, particles: 12, name: 'Ssj2' },
            { score: 20, color: 'rgba(255, 215, 0, 0.5)', radius: 20, particles: 16, name: 'Ssj3' },
            { score: 25, color: 'rgba(0, 191, 255, 0.5)', radius: 25, particles: 20, name: 'Ssj Blue' },
            { score: 30, color: 'rgba(255, 255, 255, 0.7)', radius: 30, particles: 24, name: 'UI', 
      special: true, // Propiedad especial para Ultra Instinct
      heatEffect: true // Efecto de calor
    }
        ];

        function drawPlayerAura() {
            // Encontrar el nivel de aura actual basado en el puntaje
            const auraLevel = auraLevels.filter(level => gameState.score >= level.score).pop();
            
            if (auraLevel) {
                if (player.currentAuraLevel !== auraLevels.indexOf(auraLevel)) {
                    player.currentAuraLevel = auraLevels.indexOf(auraLevel);
                    // Mostrar mensaje de transformación
                    showTransformationMessage(auraLevel.name);
                }

                ctx.save();
                
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;

                // Dibujar aura base
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, player.width/2,
                    centerX, centerY, player.width/2 + auraLevel.radius
                );
                
                gradient.addColorStop(0, auraLevel.color);
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.arc(centerX, centerY, player.width/2 + auraLevel.radius, 0, Math.PI * 2);
                ctx.fill();

                // Dibujar partículas del aura
                player.auraAngle += 0.1;
                for (let i = 0; i < auraLevel.particles; i++) {
                    const angle = (i / auraLevel.particles) * Math.PI * 2 + player.auraAngle;
                    const x = centerX + Math.cos(angle) * (player.width/2 + auraLevel.radius);
                    const y = centerY + Math.sin(angle) * (player.height/2 + auraLevel.radius);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = auraLevel.color;
                    ctx.fill();
                }

                // Efecto de energía
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * auraLevel.radius;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5);
                    ctx.strokeStyle = auraLevel.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        function showTransformationMessage(transformationName) {
    if (gameState.transformationActive) return; // Evita mostrar el mensaje repetidamente

    gameState.transformationActive = true; // Marca que el mensaje ya se mostró

    const messageBox = document.createElement("div");
    messageBox.innerText = transformationName + "!";
    messageBox.style.position = "absolute";
    messageBox.style.top = "50%";
    messageBox.style.left = "50%";
    messageBox.style.transform = "translate(-50%, -50%)";
    messageBox.style.background = "rgba(0, 0, 0, 0.8)";
    messageBox.style.color = "yellow";
    messageBox.style.padding = "20px";
    messageBox.style.fontSize = "24px";
    messageBox.style.border = "2px solid gold";
    messageBox.style.zIndex = "1000";
    messageBox.style.textAlign = "center";
    document.body.appendChild(messageBox);

    setTimeout(() => {
        document.body.removeChild(messageBox);
        gameState.transformationActive = false; // Permite nuevas transformaciones
    }, 2000); // Desaparece después de 2 segundos
}

        
        let player = {
            x: 60,
            y: canvas.height / 2,
            width: 35,
            height: 35,
            color: "#ffb700",
            speed: 5,
            velocityY: 0,
            auraAngle: 0,  // Para la rotación del aura
            currentAuraLevel: -1  // Nivel actual del aura
        };
        
        let gameState = {
            obstacles: [],
            score: 0,
            gameSpeed: 6,
            obstacleInterval: 1500,
            gameOver: false,
            gravity: 0.7,
            jump: -13,
            starSpeedMultiplier: 1 // Nuevo multiplicador para la velocidad de las estrellas
        };

        let stars = Array(150).fill().map(() => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2.5 + 0.5,
            baseSpeed: Math.random() * 3 + 1, // Velocidad base de cada estrella
            color: Math.random() > 0.7 ? '#ffeaa7' : Math.random() > 0.5 ? '#81ecec' : '#ffffff'
        }));

        let particles = [];

        function createParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1,
                    color: color
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = `rgba(${p.color}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.life * 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0c0c2c');
            gradient.addColorStop(1, '#1a1a4f');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fillStyle = star.color;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, 0.1)`;
                ctx.fill();
                
                // Usar la velocidad base multiplicada por el multiplicador del juego
                star.x -= star.baseSpeed * gameState.starSpeedMultiplier;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }
            });

            ['rgba(255, 71, 87, 0.03)', 'rgba(0, 255, 136, 0.03)', 'rgba(126, 214, 223, 0.03)'].forEach((color, i) => {
                let gradient = ctx.createRadialGradient(
                    canvas.width * (0.3 + i * 0.3), canvas.height * 0.5, 0,
                    canvas.width * (0.3 + i * 0.3), canvas.height * 0.5, canvas.width * 0.4
                );
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });
        }

        function drawPlayer() {
            drawPlayerAura(); // Dibujar el aura antes que el jugador


            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.roundRect(player.x, player.y, player.width, player.height, 8);
            ctx.fill();
            
            ctx.fillStyle = "#ffee60";
            ctx.fillRect(player.x + player.width - 10, player.y + 8, 6, player.height - 16);
        }
        
        function drawObstacles() {
            gameState.obstacles.forEach(obstacle => {
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 20;
                
                const gradient = ctx.createLinearGradient(obstacle.x, 0, obstacle.x + obstacle.width, 0);
                gradient.addColorStop(0, '#00ff88');
                gradient.addColorStop(1, '#00b894');
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.roundRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = "rgba(0, 255, 136, 0.6)";
                ctx.fillRect(obstacle.x + obstacle.width * 0.2, obstacle.y, obstacle.width * 0.1, obstacle.height);
                ctx.fillRect(obstacle.x + obstacle.width * 0.7, obstacle.y, obstacle.width * 0.1, obstacle.height);
            });
        }
        
        function createObstacle() {
            if (gameState.gameOver) return;
            
            const patterns = [
                () => {
                    const gap = 120;
                    const gapPosition = Math.random() * (canvas.height - gap - 100) + 50;
                    return [
                        {
                            x: canvas.width,
                            y: 0,
                            width: 40,
                            height: gapPosition,
                            passed: false
                        },
                        {
                            x: canvas.width,
                            y: gapPosition + gap,
                            width: 40,
                            height: canvas.height - (gapPosition + gap),
                            passed: false
                        }
                    ];
                },
                () => {
                    const obstacles = [];
                    const steps = 3;
                    for (let i = 0; i < steps; i++) {
                        obstacles.push({
                            x: canvas.width + (i * 80),
                            y: canvas.height - (100 + i * 60),
                            width: 40,
                            height: 100 + i * 60,
                            passed: false
                        });
                    }
                    return obstacles;
                },
                () => {
                    const obstacles = [];
                    const count = 3;
                    for (let i = 0; i < count; i++) {
                        obstacles.push({
                            x: canvas.width + (i * 150),
                            y: canvas.height - 80,
                            width: 40,
                            height: 80,
                            passed: false
                        });
                    }
                    return obstacles;
                }
            ];

            const pattern = patterns[Math.floor(Math.random() * patterns.length)];
            const newObstacles = pattern();
            gameState.obstacles.push(...newObstacles);
        }
        
        function updateObstacles() {
            gameState.obstacles.forEach(obstacle => {
                obstacle.x -= gameState.gameSpeed;
                
                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    gameState.score++;
                    obstacle.passed = true;
                    scoreElement.textContent = `Puntos: ${gameState.score}`;
                    
                    if (gameState.score % 2 === 0) {
                        gameState.gameSpeed += 0.4;
                        // Aumentar la velocidad de las estrellas proporcionalmente
                        gameState.starSpeedMultiplier = 1 + (gameState.gameSpeed - 6) / 6;
                        
                        if (gameState.obstacleInterval > 800) {
                            gameState.obstacleInterval -= 50;
                        }
                    }
                }
            });
            
            gameState.obstacles = gameState.obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
        }
        
        function checkCollision() {
            return gameState.obstacles.some(obstacle => {
                const collision = player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y;
                
                if (collision) {
                    createParticles(player.x + player.width/2, player.y + player.height/2, '255, 254, 88');
                    createParticles(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, '0, 255, 136');
                }
                
                return collision;
            });
        }
        
        function updatePlayer() {
            player.velocityY += gameState.gravity;
            player.y += player.velocityY;
            
            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.velocityY = 0;
            }
        }
        
        function gameLoop() {
            if (gameState.gameOver) {
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, 'rgba(12, 12, 44, 0.9)');
                gradient.addColorStop(1, 'rgba(26, 26, 79, 0.9)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = "#00ff88";
                ctx.font = "bold 40px Arial";
                ctx.textAlign = "center";
                ctx.fillText("¡Perdiste! :(", canvas.width/2, canvas.height/2 - 40);
                
                ctx.font = "28px Arial";
                ctx.fillText(`Puntos totales: ${gameState.score}`, canvas.width/2, canvas.height/2 + 20);
                
                updateParticles();
                drawParticles();
                return;
            }
            
            drawBackground();
            updatePlayer();
            drawPlayer();
            updateObstacles();
            drawObstacles();
            updateParticles();
            drawParticles();
            
            if (checkCollision()) {
                gameState.gameOver = true;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function resetGame() {
            player.y = canvas.height / 2;
            player.velocityY = 0;
            player.currentAuraLevel = -1;
            particles = [];
            gameState = {
                obstacles: [],
                score: 0,
                gameSpeed: 6,
                obstacleInterval: 1500,
                gameOver: false,
                gravity: 0.7,
                jump: -13,
                starSpeedMultiplier: 1 // Reiniciar el multiplicador de velocidad de las estrellas
            };
            scoreElement.textContent = "Puntos: 0";
            gameLoop();
        }
        
        document.addEventListener("keydown", event => {
            if (event.key === "ArrowUp") {
                player.velocityY = gameState.jump;
            } else if (event.key === "r" || event.key === "R") {
                if (gameState.gameOver) {
                    resetGame();
                }
            }
        });
        
        setInterval(createObstacle, gameState.obstacleInterval);
        gameLoop();
    </script>
</body>
</html>